import fs from "fs";
import path from "path";
import { FolderInfo, RunOptions, RunResponse, ScanOptions, ScanResult } from "./types.js";

const { readdir, writeFile, realpath, mkdir } = fs.promises;

type CommentMap = Record<string, string>;

type DirectoryFrame = {
  dirPath: string;
  depth: number;
};

type TreeNode = Map<string, TreeNode>;

function normaliseComments(comments: CommentMap, rootPath: string): CommentMap {
  const normalised: CommentMap = {};
  for (const [key, value] of Object.entries(comments)) {
    normalised[path.resolve(rootPath, key)] = value;
  }
  return normalised;
}

function toRelativePath(rootPath: string, fullPath: string): string {
  return path.relative(rootPath, fullPath) || ".";
}

function folderLabel(folder: FolderInfo): string {
  return folder.relativePath || ".";
}

function basePathWithoutExtension(filePath: string): string {
  return filePath.replace(/\.[^.]+$/, "");
}

export async function scanDirectory({
  rootPath,
  maxDepth,
  minFiles,
  comments,
}: ScanOptions): Promise<ScanResult> {
  if (maxDepth < 0) {
    throw new Error("maxDepth must be zero or greater");
  }
  if (minFiles < 0) {
    throw new Error("minFiles must be zero or greater");
  }

  const resolvedRoot = await realpath(rootPath);
  const commentMap = normaliseComments(comments ?? {}, resolvedRoot);

  const folders: FolderInfo[] = [];
  const warnings: string[] = [];

  const stack: DirectoryFrame[] = [{ dirPath: resolvedRoot, depth: 0 }];

  while (stack.length > 0) {
    const frame = stack.pop();
    if (!frame) {
      continue;
    }
    const { dirPath, depth } = frame;

    if (depth > maxDepth) {
      continue;
    }

    let dirEntries: fs.Dirent[];
    try {
      dirEntries = await readdir(dirPath, { withFileTypes: true });
    } catch (error) {
      warnings.push(`Skipped ${dirPath}: ${(error as Error).message}`);
      continue;
    }

    const fileCount = dirEntries.filter((entry) => entry.isFile()).length;
    if (depth === 0 || fileCount >= minFiles) {
      const comment = commentMap[dirPath] ?? "";
      folders.push({
        absolutePath: dirPath,
        relativePath: toRelativePath(resolvedRoot, dirPath),
        depth,
        fileCount,
        comment,
      });
    }

    const childDirectories = dirEntries
      .filter((entry) => entry.isDirectory() && !entry.isSymbolicLink())
      .map((entry) => path.join(dirPath, entry.name))
      .sort((a, b) => a.localeCompare(b));

    for (let index = childDirectories.length - 1; index >= 0; index -= 1) {
      stack.push({ dirPath: childDirectories[index]!, depth: depth + 1 });
    }
  }

  folders.sort((a, b) => folderLabel(a).localeCompare(folderLabel(b)));

  return { folders, warnings };
}

export async function loadExistingFile(filePath: string): Promise<CommentMap> {
  try {
    const content = await fs.promises.readFile(filePath, "utf-8");
    const extension = path.extname(filePath).toLowerCase();

    if (extension === '.json' || content.trim().startsWith('{')) {
      // Handle JSON files
      return loadFromJson(content);
    } else if (extension === '.csv' || content.includes('folder,absolute_path,depth,file_count,comment')) {
      // Handle CSV files
      return loadFromCsv(content);
    } else if (extension === '.html' || content.includes('<html') || content.includes('<!DOCTYPE html')) {
      // Handle HTML files
      return loadFromHtml(content);
    } else {
      throw new Error("Unsupported file format. Please select a JSON, HTML, or CSV file generated by Share and Tell.");
    }
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to load existing file: ${error.message}`);
    }
    throw error;
  }
}

function loadFromJson(content: string): CommentMap {
  const data = JSON.parse(content);

  // Validate schema
  if (typeof data !== "object" || data === null) {
    throw new Error("Existing file must be a JSON object");
  }

  const requiredKeys = ["generated_at", "root", "max_depth", "min_files", "folders", "warnings"];
  const missingKeys = requiredKeys.filter(key => !(key in data));
  if (missingKeys.length > 0) {
    throw new Error(`Existing file missing required keys: ${missingKeys.join(", ")}`);
  }

  if (!Array.isArray(data.folders)) {
    throw new Error("Existing file 'folders' must be a list");
  }

  const comments: CommentMap = {};
  for (const folder of data.folders) {
    if (typeof folder !== "object" || folder === null) {
      throw new Error("Each folder must be an object");
    }
    if (!("folder" in folder) || !("comment" in folder)) {
      throw new Error("Each folder must have 'folder' and 'comment' keys");
    }
    const folderPath = folder.folder;
    const comment = folder.comment;
    if (typeof comment !== "string") {
      throw new Error("Comment must be a string");
    }
    comments[folderPath] = comment;
  }

  return comments;
}

function loadFromCsv(content: string): CommentMap {
  const lines = content.trim().split('\n');
  if (lines.length < 2) {
    throw new Error("CSV file must have at least a header row and one data row");
  }

  const headers = lines[0].split(',').map(h => h.trim());
  const expectedHeaders = ['folder', 'absolute_path', 'depth', 'file_count', 'comment'];
  const hasExpectedHeaders = expectedHeaders.every(header => headers.includes(header));

  if (!hasExpectedHeaders) {
    throw new Error("CSV file must have the expected headers: folder, absolute_path, depth, file_count, comment");
  }

  const folderIndex = headers.indexOf('folder');
  const commentIndex = headers.indexOf('comment');

  const comments: CommentMap = {};
  for (let i = 1; i < lines.length; i++) {
    const cells = parseCsvLine(lines[i]);
    if (cells.length > folderIndex && cells.length > commentIndex) {
      const folderPath = cells[folderIndex]?.trim() || '';
      const comment = cells[commentIndex]?.trim() || '';
      if (folderPath && comment) {
        comments[folderPath] = comment;
      }
    }
  }

  return comments;
}

function parseCsvLine(line: string): string[] {
  const result: string[] = [];
  let current = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i++; // skip next quote
      } else {
        inQuotes = !inQuotes;
      }
    } else if (char === ',' && !inQuotes) {
      result.push(current);
      current = '';
    } else {
      current += char;
    }
  }

  result.push(current);
  return result;
}

function loadFromHtml(content: string): CommentMap {
  const comments: CommentMap = {};

  const folderRegex = /<td class="folder">([^<]+)<\/td>/g;
  const commentRegex = /<td class="comment">([^<]*)<\/td>/g;

  let folderMatch: RegExpExecArray | null;
  let commentMatch: RegExpExecArray | null;

  while ((folderMatch = folderRegex.exec(content)) !== null && (commentMatch = commentRegex.exec(content)) !== null) {
    const folderPath = folderMatch[1].trim();
    const comment = commentMatch[1]?.trim() ?? "";
    comments[folderPath] = comment;
  }

  return comments;
}

export async function runAndWrite(options: RunOptions): Promise<RunResponse> {
  // Load existing comments if a file is specified
  let comments = options.comments ?? {};
  if (options.existingFilePath) {
    const existingComments = await loadExistingFile(options.existingFilePath);
    comments = { ...existingComments, ...comments };
  }

  const scanOptions: ScanOptions = {
    rootPath: options.rootPath,
    maxDepth: options.maxDepth,
    minFiles: options.minFiles,
    comments,
  };

  const result = await scanDirectory(scanOptions);
  const outputs: RunResponse["writtenFiles"] = {};

  const baseFile = basePathWithoutExtension(options.outputBasePath);

  const payloads: Array<{ format: keyof RunResponse["writtenFiles"]; data: string }>
    = [];

  for (const format of options.formats) {
    switch (format) {
      case "json":
        payloads.push({ format, data: renderJson(result, options) });
        break;
      case "html":
        payloads.push({ format, data: renderHtml(result, options) });
        break;
      case "csv":
        payloads.push({ format, data: renderCsv(result) });
        break;
      default:
        break;
    }
  }

  for (const payload of payloads) {
    const targetPath = `${baseFile}.${payload.format}`;
    await mkdir(path.dirname(targetPath), { recursive: true });
    await writeFile(targetPath, payload.data, "utf-8");
    outputs[payload.format] = targetPath;
  }

  return { result, writtenFiles: outputs };
}

export function renderJson(result: ScanResult, options: ScanOptions): string {
  const document = {
    generated_at: new Date().toISOString(),
    root: path.resolve(options.rootPath),
    max_depth: options.maxDepth,
    min_files: options.minFiles,
    folders: result.folders.map((folder) => ({
      folder: folderLabel(folder),
      absolute_path: folder.absolutePath,
      depth: folder.depth,
      file_count: folder.fileCount,
      comment: folder.comment ?? "",
    })),
    warnings: result.warnings,
  };

  return JSON.stringify(document, null, 2);
}

export function renderCsv(result: ScanResult): string {
  const lines = ["folder,absolute_path,depth,file_count,comment"];
  for (const folder of [...result.folders].sort((a, b) => folderLabel(a).localeCompare(folderLabel(b)))) {
    const row = [
      folderLabel(folder),
      folder.absolutePath,
      folder.depth.toString(),
      folder.fileCount.toString(),
      folder.comment ?? "",
    ];
    lines.push(row.join(","));
  }
  return `${lines.join("\n")}\n`;
}

export function renderHtml(result: ScanResult, options: ScanOptions): string {
  const rows = result.folders.map(folder =>
    `<tr><td>${folderLabel(folder)}</td><td>${folder.depth}</td><td>${folder.fileCount}</td><td>${folder.comment ?? ""}</td></tr>`
  ).join("");

  const warnings = result.warnings.length > 0
    ? `<section><h2>Warnings</h2><ul>${result.warnings.map(w => `<li>${w}</li>`).join("")}</ul></section>`
    : "";

  return `<!DOCTYPE html>
<html>
<head>
  <title>Share and Tell Report</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 2rem; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #f2f2f2; }
  </style>
</head>
<body>
  <h1>Share and Tell Report</h1>
  <p>Root: ${options.rootPath}</p>
  <p>Generated: ${new Date().toISOString()}</p>
  <table>
    <thead><tr><th>Folder</th><th>Depth</th><th>Files</th><th>Comment</th></tr></thead>
    <tbody>${rows}</tbody>
  </table>
  ${warnings}
</body>
</html>`;
}